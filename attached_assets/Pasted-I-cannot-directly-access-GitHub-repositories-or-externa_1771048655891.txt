I cannot directly access GitHub repositories or external URLs. However, I've already analyzed all **41 files** you shared from your Tabibi codebase in the documents above.

Let me provide a **comprehensive security audit report** based on everything I've reviewed:

---

# ğŸ”’ Tabibi Healthcare - Complete Security Audit Report

## Executive Summary
**Risk Level: HIGH** - Several critical vulnerabilities found that could lead to:
- API quota drain ($$$)
- Patient data exposure (HIPAA/GDPR violations)
- Service disruption (DoS)
- Authentication bypass

---

## ğŸ”´ CRITICAL Issues (Fix Immediately)

### C1. No Authentication on Medical AI Endpoints
**Files:** `server/routes.ts` lines 78, 208, 265, 330

```typescript
// âŒ CURRENT - Anyone can use your AI endpoints
app.post("/api/assess", async (req: Request, res: Response) => {
  // NO AUTH CHECK!
  const { messages, patientProfile } = req.body;
```

**Risk:** 
- Anyone can drain your Gemini API quota
- Costs you money
- Medical data can be extracted

**Fix:**
```typescript
// âœ… Add authentication middleware
const requireAuth = (req: Request, res: Response, next: NextFunction) => {
  if (!req.session.userId) {
    return res.status(401).json({ message: "Authentication required" });
  }
  next();
};

// Apply to all sensitive routes
app.post("/api/assess", requireAuth, async (req: Request, res: Response) => {
  // Now protected
});

app.post("/api/analyze-medication", requireAuth, async (req, res) => {/*...*/});
app.post("/api/check-interactions", requireAuth, async (req, res) => {/*...*/});
app.post("/api/process-rppg", requireAuth, async (req, res) => {/*...*/});
```

### C2. Exposed API Keys in Client Code
**Files:** `lib/firebase.ts`, `app.json`

```typescript
// âŒ Firebase config exposed in client bundle
const firebaseConfig = {
  apiKey: process.env.EXPO_PUBLIC_FIREBASE_API_KEY, // Exposed to client!
  authDomain: process.env.EXPO_PUBLIC_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.EXPO_PUBLIC_FIREBASE_PROJECT_ID,
};
```

**Risk:** 
- Firebase API key is public (by design, but needs restrictions)
- Anyone can see your project ID

**Fix:**
1. **Firebase Console** â†’ Project Settings â†’ App restrictions:
   - Add your app bundle IDs
   - Restrict API key to specific domains
   - Enable App Check

2. **Add App Check** (prevents API abuse):
```bash
npm install firebase/app-check
```

```typescript
// lib/firebase.ts
import { initializeAppCheck, ReCaptchaV3Provider } from "firebase/app-check";

const app = initializeApp(firebaseConfig);

if (typeof window !== 'undefined') {
  initializeAppCheck(app, {
    provider: new ReCaptchaV3Provider(process.env.EXPO_PUBLIC_RECAPTCHA_SITE_KEY!),
    isTokenAutoRefreshEnabled: true
  });
}
```

### C3. No Rate Limiting - DoS Vulnerability
**Files:** `server/index.ts`, `server/routes.ts`

**Risk:**
- Attacker can spam AI endpoints
- Your server crashes
- Gemini bill skyrockets

**Fix:**
```bash
npm install express-rate-limit
```

```typescript
// server/middleware/rate-limit.ts
import rateLimit from 'express-rate-limit';

export const generalLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 min
  max: 100,
  message: "Too many requests, please try again later",
  standardHeaders: true,
  legacyHeaders: false,
});

export const aiLimiter = rateLimit({
  windowMs: 60 * 1000, // 1 min
  max: 10, // Only 10 AI calls per minute
  message: "Too many AI requests, please slow down",
  skipSuccessfulRequests: false,
});

export const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 5, // Only 5 login attempts per 15 min
  message: "Too many login attempts, try again later",
});
```

```typescript
// server/index.ts
import { generalLimiter, aiLimiter, authLimiter } from './middleware/rate-limit';

app.use('/api/', generalLimiter);
app.use('/api/assess', aiLimiter);
app.use('/api/analyze-medication', aiLimiter);
app.use('/api/check-interactions', aiLimiter);
app.use('/api/auth/firebase', authLimiter);
```

### C4. Missing Input Validation - Injection Risk
**Files:** `server/routes.ts` - all endpoints

```typescript
// âŒ No validation on user input
const { messages, patientProfile } = req.body;
// What if messages contains malicious code?
```

**Fix - Create validation schemas:**
```typescript
// server/validation/schemas.ts
import { z } from "zod";

export const messageSchema = z.object({
  role: z.enum(["user", "assistant"]),
  content: z.string().min(1).max(5000),
  imageData: z.string().max(10485760).optional(), // 10MB base64
  mimeType: z.enum(["image/jpeg", "image/png", "image/jpg"]).optional(),
});

export const patientProfileSchema = z.object({
  name: z.string().max(100).optional(),
  age: z.number().int().min(0).max(150).optional(),
  weight: z.number().min(0).max(500).optional(),
  height: z.number().min(0).max(300).optional(),
  gender: z.enum(["male", "female", "other"]).optional(),
  bloodType: z.string().max(10).optional(),
  isPediatric: z.boolean().optional(),
  medications: z.array(z.string().max(200)).max(50).optional(),
  conditions: z.array(z.string().max(200)).max(50).optional(),
  allergies: z.array(z.string().max(200)).max(50).optional(),
});

export const assessmentRequestSchema = z.object({
  messages: z.array(messageSchema).min(1).max(50),
  patientProfile: patientProfileSchema.optional(),
});

export const medicationAnalysisSchema = z.object({
  imageBase64: z.string().min(100).max(10485760), // 10MB
  mimeType: z.enum(["image/jpeg", "image/png", "image/jpg"]),
});

export const interactionCheckSchema = z.object({
  medications: z.array(z.string().max(200)).min(2).max(20).optional(),
  currentMedications: z.array(z.string().max(200)).max(20).optional(),
  newMedication: z.string().max(200).optional(),
  language: z.enum(["en", "ar"]).default("ar"),
}).refine(
  data => data.medications || (data.currentMedications && data.newMedication),
  { message: "Either medications array or currentMedications + newMedication required" }
);
```

```typescript
// server/routes.ts
import { 
  assessmentRequestSchema, 
  medicationAnalysisSchema,
  interactionCheckSchema 
} from './validation/schemas';

app.post("/api/assess", requireAuth, async (req: Request, res: Response) => {
  try {
    const validation = assessmentRequestSchema.safeParse(req.body);
    if (!validation.success) {
      return res.status(400).json({ 
        error: "Invalid request", 
        details: validation.error.issues 
      });
    }
    
    const { messages, patientProfile } = validation.data;
    // Now safe to use
  } catch (error) {
    // ...
  }
});
```

### C5. Insecure Session Configuration
**Files:** `server/index.ts` line 150-163

```typescript
// âŒ Session not secure in production
cookie: {
  maxAge: 30 * 24 * 60 * 60 * 1000,
  httpOnly: true,
  secure: false, // âŒ Always false!
  sameSite: "lax", // âŒ Not strict enough
}
```

**Fix:**
```typescript
const isProduction = process.env.NODE_ENV === 'production';

session({
  store: new PgStore({
    conString: process.env.DATABASE_URL,
    createTableIfMissing: true,
  }),
  secret: process.env.SESSION_SECRET || (() => {
    if (isProduction) throw new Error("SESSION_SECRET required in production");
    return "dev-only-secret";
  })(),
  resave: false,
  saveUninitialized: false,
  proxy: isProduction, // Trust proxy in production
  cookie: {
    maxAge: 30 * 24 * 60 * 60 * 1000,
    httpOnly: true,
    secure: isProduction, // âœ… HTTPS only in production
    sameSite: isProduction ? "strict" : "lax", // âœ… Strict in prod
    domain: isProduction ? `.${process.env.REPLIT_DEV_DOMAIN}` : undefined,
  },
})
```

---

## âš ï¸ HIGH Issues

### H1. Patient Data Logged in Plain Text
**Files:** `server/routes.ts` - multiple locations

```typescript
console.error("Assessment error:", error);
// âŒ This could log entire patient profile!
```

**Fix:**
```typescript
// server/utils/logger.ts
export const sanitizeError = (error: unknown) => {
  if (error instanceof Error) {
    return {
      message: error.message,
      stack: process.env.NODE_ENV === 'development' ? error.stack : undefined,
    };
  }
  return { message: "Unknown error" };
};

// Never log req.body in health endpoints
console.error("Assessment error:", sanitizeError(error));
```

### H2. Google Maps API Key Exposed
**Files:** `server/routes.ts` line 361

```typescript
const apiKey = process.env.GOOGLE_MAPS_API_KEY;
// âŒ Used in client-visible URLs
photos: place.photos.slice(0, 1).map((p: any) => 
  `https://maps.googleapis.com/maps/api/place/photo?...&key=${apiKey}`
)
```

**Risk:** API key visible in image URLs sent to client

**Fix:**
1. **Proxy images through your server:**
```typescript
// Don't send API key to client
photos: place.photos.slice(0, 1).map((p: any) => 
  `/api/place-photo/${p.photo_reference}`
)

// Create proxy endpoint
app.get("/api/place-photo/:photoRef", async (req, res) => {
  const { photoRef } = req.params;
  const url = `https://maps.googleapis.com/maps/api/place/photo?maxwidth=400&photo_reference=${photoRef}&key=${process.env.GOOGLE_MAPS_API_KEY}`;
  
  const response = await fetch(url);
  const buffer = await response.arrayBuffer();
  
  res.set('Content-Type', 'image/jpeg');
  res.set('Cache-Control', 'public, max-age=86400');
  res.send(Buffer.from(buffer));
});
```

2. **Restrict API key in Google Cloud Console:**
   - API restrictions: Only Maps SDK, Places API
   - Application restrictions: HTTP referrers (your domain only)

### H3. No CSRF Protection
**Files:** `server/index.ts`

Sessions are vulnerable to CSRF attacks.

**Fix:**
```bash
npm install csurf
```

```typescript
import csrf from 'csurf';

const csrfProtection = csrf({ cookie: false }); // Use session

// Apply to state-changing routes
app.post('/api/auth/*', csrfProtection);
app.post('/api/assess', csrfProtection);

// Send token to client
app.get('/api/csrf-token', csrfProtection, (req, res) => {
  res.json({ csrfToken: req.csrfToken() });
});
```

### H4. Weak CORS Configuration
**Files:** `server/index.ts` line 28-32

```typescript
// âŒ Allows ANY localhost port
const isLocalhost =
  origin?.startsWith("http://localhost:") ||
  origin?.startsWith("http://127.0.0.1:");
```

**Fix:**
```typescript
const allowedOrigins = new Set<string>();

if (process.env.REPLIT_DEV_DOMAIN) {
  allowedOrigins.add(`https://${process.env.REPLIT_DEV_DOMAIN}`);
}

if (process.env.REPLIT_DOMAINS) {
  process.env.REPLIT_DOMAINS.split(",").forEach(d => {
    allowedOrigins.add(`https://${d.trim()}`);
  });
}

// Only allow specific localhost in development
if (process.env.NODE_ENV !== 'production') {
  allowedOrigins.add('http://localhost:8081');
  allowedOrigins.add('http://localhost:19006'); // Expo web
}

const origin = req.header("origin");

if (origin && allowedOrigins.has(origin)) {
  res.header("Access-Control-Allow-Origin", origin);
  res.header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
  res.header("Access-Control-Allow-Headers", "Content-Type, X-CSRF-Token");
  res.header("Access-Control-Allow-Credentials", "true");
} else if (origin) {
  console.warn(`Blocked CORS request from unauthorized origin: ${origin}`);
}
```

---

## âš¡ MEDIUM Issues

### M1. No Request Size Validation
**Files:** `server/index.ts` line 47

```typescript
limit: "50mb", // âŒ Way too large
```

**Fix:**
```typescript
// Default limit
app.use(express.json({ limit: "1mb" }));

// Specific limits for image routes
app.use("/api/analyze-medication", express.json({ 
  limit: "5mb",
  verify: (req, res, buf) => {
    if (buf.length > 5 * 1024 * 1024) {
      throw new Error("Image too large");
    }
  }
}));

app.use("/api/assess", express.json({ limit: "2mb" }));
```

### M2. Error Messages Leak Information
**Files:** Multiple

```typescript
// âŒ Exposes internal structure
return res.status(500).json({ error: "Failed to fetch nearby facilities" });
```

**Fix:**
```typescript
// Don't expose internal errors to client
const errorMessage = process.env.NODE_ENV === 'development' 
  ? error.message 
  : "An error occurred";

return res.status(500).json({ error: errorMessage });
```

### M3. No Database Connection Pooling Limits
**Files:** `server/storage.ts`

```typescript
const pool = new Pool({ connectionString: process.env.DATABASE_URL! });
// âŒ No connection limits
```

**Fix:**
```typescript
const pool = new Pool({ 
  connectionString: process.env.DATABASE_URL,
  max: 20, // Maximum pool size
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000,
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,
});

pool.on('error', (err, client) => {
  console.error('Unexpected database pool error:', err);
});
```

### M4. Firebase Token Not Validated Properly
**Files:** `server/firebase-auth.ts`

```typescript
if (!res.ok) return null; // âŒ Silent failure
```

**Fix:**
```typescript
if (!res.ok) {
  const errorText = await res.text();
  console.error(`Firebase token verification failed: ${res.status}`, {
    status: res.status,
    error: errorText.substring(0, 200), // Don't log full token
  });
  return null;
}

const data = await res.json();
if (!data.users || data.users.length === 0) {
  console.warn('Firebase returned no users for valid token');
  return null;
}
```

---

## ğŸ” Code Quality & Debugging Issues

### D1. Silent Error Catching
**Files:** `lib/storage.ts`, `contexts/AuthContext.tsx`

```typescript
try {
  // ...
} catch {} // âŒ Silent catch
```

**Fix:**
```typescript
try {
  // ...
} catch (error) {
  console.error('Storage error:', error);
  // Optionally: Send to error tracking service
}
```

### D2. No Error Boundary for Specific Components
**Files:** You have a global ErrorBoundary, but medical features need specific handling

**Fix:**
```typescript
// components/MedicalErrorBoundary.tsx
export class MedicalErrorBoundary extends ErrorBoundary {
  componentDidCatch(error: Error, info: { componentStack: string }): void {
    // Log medical feature errors separately
    console.error('Medical feature error:', {
      error: error.message,
      component: info.componentStack.split('\n')[1],
    });
    
    // Don't log patient data
    super.componentDidCatch(error, info);
  }
}
```

### D3. Race Conditions in Auth Context
**Files:** `contexts/AuthContext.tsx` line 35-60

```typescript
useEffect(() => {
  let mounted = true;
  // ... async operations
  if (mounted) setUser(backendUser);
  // âŒ Race condition if component unmounts during fetch
```

**Fix:**
```typescript
useEffect(() => {
  const abortController = new AbortController();
  
  const syncUser = async (firebaseUser: FirebaseUser) => {
    try {
      const backendUser = await syncWithBackend(firebaseUser, abortController.signal);
      if (!abortController.signal.aborted) {
        setUser(backendUser);
      }
    } catch (error) {
      if (!abortController.signal.aborted) {
        console.error('Sync failed:', error);
      }
    }
  };
  
  return () => {
    abortController.abort();
    unsubscribe();
  };
}, []);
```

---

## ğŸ“‹ Complete Security Patch

Create this file and apply the changes:

```typescript
// APPLY_SECURITY_PATCHES.md

### Step 1: Install Dependencies
npm install express-rate-limit helmet csurf zod
npm install --save-dev @types/helmet @types/csurf

### Step 2: Environment Variables
Add to .env:
SESSION_SECRET=<generate-strong-random-key>
RECAPTCHA_SITE_KEY=<your-recaptcha-key>

### Step 3: Apply Patches
1. Create server/middleware/auth.ts (authentication middleware)
2. Create server/middleware/rate-limit.ts (rate limiting)
3. Create server/validation/schemas.ts (input validation)
4. Update server/index.ts (security headers)
5. Update server/routes.ts (apply middleware)

### Step 4: Firebase Security
1. Enable App Check in Firebase Console
2. Restrict API keys by domain
3. Add bundle ID restrictions

### Step 5: Google Maps Security
1. Restrict API key in Google Cloud Console
2. Create photo proxy endpoint
3. Remove API key from client responses

### Step 6: Testing
1. Test all endpoints with invalid data
2. Test rate limiting
3. Test authentication flows
4. Check logs for patient data leaks
```

---

## ğŸ¯ Priority Action Items

**This Week:**
1. âœ… Add authentication to all `/api/*` endpoints
2. âœ… Implement rate limiting
3. âœ… Add input validation with Zod
4. âœ… Secure session cookies for production

**This Month:**
1. âœ… Add CSRF protection
2. âœ… Implement App Check for Firebase
3. âœ… Restrict Google Maps API key
4. âœ… Add comprehensive error handling
5. âœ… Remove patient data from logs

**Before Launch:**
1. âœ… Security penetration testing
2. âœ… HIPAA compliance review
3. âœ… Code audit by security professional
4. âœ… Privacy policy & terms of service
5. âœ… Incident response plan

---

Would you like me to:
1. **Create ready-to-use patch files** for each security fix?
2. **Write a complete security middleware package** for your app?
3. **Generate a HIPAA compliance checklist** specifically for medical apps?
4. **Help set up monitoring/alerting** for security events?

Let me know which area you'd like to tackle first! ğŸš€